package org.firstinspires.ftc.teamcode.Teleop;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.*;
import android.graphics.Color;

@TeleOp(name="Defence_TeleOp_ShootFixed", group="Linear Opmode")
public class Drive extends LinearOpMode {

    // ===== HARDWARE =====
    DcMotor FL, FR, BL, BR;
    DcMotor Shooter, Intake, Spindex;
    Servo Transfer, HoodL, HoodR;
    NormalizedColorSensor colorSensor;

    // ===== SPINDEX POSITIONS =====
    static final int[] INDEX_POSITIONS = {0, 475, 950};      // indexing positions
    static final int[] SHOOT_POSITIONS = {1198, 1653, 2140}; // shooting positions
    static final double SPINDEX_FAST = 0.9;
    static final double SPINDEX_SLOW = 0.1;
    static final int SLOW_DOWN_TICKS = 5;
    static final int POSITION_TOLERANCE = 5; // tolerance for reaching target
    static final long ANTI_JAM_TIME = 500;

    int currentIndex = 0;           // current indexing position
    int shootingIndex = 0;          // current shooting target index
    boolean spindexBusy = false;
    long spindexStartTime = 0;

    // ===== SERVO CONSTANTS =====
    static final double TRANSFER_OUT = 0.5;
    static final double TRANSFER_IN = 0.0;
    static final long SERVO_OUT_TIME = 600;
    static final long SERVO_IN_TIME = 600;

    // ===== SHOOTING DELAYS =====
    static final long FIRST_SHOT_DELAY = 500;    // delay before first shot
    static final long WAIT_BETWEEN_SHOTS = 1000; // delay between shots

    // ===== SHOOTER STATE =====
    boolean shooterPrev = false;
    long stateTime = 0;
    int shotsFired = 0;
    static final int MAX_SHOTS = 3;

    enum ShootState { IDLE, SPINDEX_MOVE, SERVO_OUT, SERVO_IN, FINAL_SPIN }
    ShootState shootState = ShootState.IDLE;

    @Override
    public void runOpMode() {

        // ===== MAP HARDWARE =====
        FL = hardwareMap.get(DcMotor.class, "CH_motor2");
        FR = hardwareMap.get(DcMotor.class, "EH_motor1");
        BL = hardwareMap.get(DcMotor.class, "CH_motor1");
        BR = hardwareMap.get(DcMotor.class, "EH_motor3");

        Shooter = hardwareMap.get(DcMotor.class, "CH_motor0");
        Intake = hardwareMap.get(DcMotor.class, "EH_motor2");
        Spindex = hardwareMap.get(DcMotor.class, "EH_motor0");

        Transfer = hardwareMap.get(Servo.class, "EH_servo0");
        HoodR = hardwareMap.get(Servo.class, "EH_servo4");
        HoodL = hardwareMap.get(Servo.class, "CH_servo5");

        colorSensor = hardwareMap.get(NormalizedColorSensor.class, "Colorsensor");
        colorSensor.setGain(3);

        // ===== DIRECTIONS =====
        BL.setDirection(DcMotor.Direction.REVERSE);
        FR.setDirection(DcMotor.Direction.FORWARD);
        Intake.setDirection(DcMotorSimple.Direction.REVERSE);

        // ===== BRAKE BEHAVIOR =====
        FL.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        FR.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        BL.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        BR.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        Spindex.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

        // ===== SPINDEX INIT =====
        Spindex.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        Spindex.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        waitForStart();

        float[] hsv = new float[3];

        while (opModeIsActive()) {

            // ===== DRIVE =====
            double y = -gamepad1.left_stick_y;
            double x = gamepad1.left_stick_x;
            double rx = gamepad1.right_stick_x;

            double fl = y + x + rx;
            double fr = y - x - rx;
            double bl = y - x + rx;
            double br = y + x - rx;

            double max = Math.max(1.0, Math.max(Math.abs(fl), Math.max(Math.abs(fr), Math.max(Math.abs(bl), Math.abs(br)))));
            FL.setPower(fl / max);
            FR.setPower(fr / max);
            BL.setPower(bl / max);
            BR.setPower(br / max);

            // ===== INTAKE / SHOOTER =====
            boolean intakeOn = gamepad1.right_trigger > 0.1;
            boolean shooterOn = gamepad1.left_trigger > 0.1;

            Intake.setPower(intakeOn ? 0.75 : 0);
            Shooter.setPower(shooterOn ? 1.0 : 0);

            // ===== COLOR SENSOR =====
            NormalizedRGBA c = colorSensor.getNormalizedColors();
            Color.RGBToHSV((int)(c.red*255), (int)(c.green*255), (int)(c.blue*255), hsv);
            float H = hsv[0], S = hsv[1];
            boolean validColor = ((H>130 && H<170 && S>0.5) || (H>200 && H<250 && S>0.4)) && !(H>60 && H<110 && S>0.6);
            boolean triggerIndex = intakeOn && validColor;

            // ===== INDEXING =====
            if (triggerIndex && !spindexBusy && currentIndex < INDEX_POSITIONS.length - 1) {
                currentIndex++;
                moveSpindexTo(INDEX_POSITIONS[currentIndex]);
            }

            // ===== SHOOTING =====
            if (shooterOn && !shooterPrev && shootState == ShootState.IDLE) {
                shotsFired = 0;
                shootingIndex = 0;
                stateTime = System.currentTimeMillis();
                shootState = ShootState.SPINDEX_MOVE;
            }
            shooterPrev = shooterOn;

            // ===== SHOOT STATE MACHINE =====
            switch (shootState) {

                case SPINDEX_MOVE:
                    // Wait for spindex to reach target within tolerance
                    if (Math.abs(Spindex.getCurrentPosition() - Spindex.getTargetPosition()) <= POSITION_TOLERANCE) {
                        // First shot delay only for the first shooting index
                        if (shootingIndex == 0 && System.currentTimeMillis() - stateTime < FIRST_SHOT_DELAY) break;
                        shootState = ShootState.SERVO_OUT;
                        stateTime = System.currentTimeMillis();
                    }
                    break;

                case SERVO_OUT:
                    Transfer.setPosition(TRANSFER_OUT);
                    if (elapsed(SERVO_OUT_TIME)) {
                        shootState = ShootState.SERVO_IN;
                        stateTime = System.currentTimeMillis();
                    }
                    break;

                case SERVO_IN:
                    Transfer.setPosition(TRANSFER_IN);
                    if (elapsed(SERVO_IN_TIME)) {
                        shotsFired++;
                        shootingIndex++;
                        stateTime = System.currentTimeMillis(); // start wait for next shot
                        if (shotsFired < MAX_SHOTS && shootingIndex < SHOOT_POSITIONS.length) {
                            shootState = ShootState.SPINDEX_MOVE;
                            moveSpindexTo(SHOOT_POSITIONS[shootingIndex]);
                        } else {
                            shootState = ShootState.FINAL_SPIN;
                        }
                    }
                    break;

                case FINAL_SPIN:
                    // Return to last indexing position
                    if (!spindexBusy) {
                        moveSpindexTo(INDEX_POSITIONS[currentIndex]);
                        shootState = ShootState.IDLE;
                    }
                    break;

                case IDLE: default: break;
            }

            // ===== UPDATE SPINDEX =====
            updateSpindex();

            // ===== TELEMETRY =====
            telemetry.addData("Spindex Pos", Spindex.getCurrentPosition());
            telemetry.addData("Current Index", currentIndex);
            telemetry.addData("Shooting Index", shootingIndex);
            telemetry.addData("Shots Fired", shotsFired);
            telemetry.addData("Spindex Busy", spindexBusy);
            telemetry.addData("Shoot State", shootState);
            telemetry.update();
        }
    }

    // ===== SPINDEX CONTROL =====
    void moveSpindexTo(int target) {
        Spindex.setTargetPosition(target);
        Spindex.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        Spindex.setPower(SPINDEX_FAST);
        spindexBusy = true;
        spindexStartTime = System.currentTimeMillis();
    }

    void updateSpindex() {
        if (!spindexBusy) {
            // Hold position at idle
            Spindex.setTargetPosition(INDEX_POSITIONS[currentIndex]);
            Spindex.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            Spindex.setPower(0.1); // small holding power
            return;
        }

        int pos = Spindex.getCurrentPosition();
        int target = Spindex.getTargetPosition();

        if (Math.abs(target - pos) < SLOW_DOWN_TICKS) Spindex.setPower(SPINDEX_SLOW);

        if (Math.abs(target - pos) <= POSITION_TOLERANCE) {
            Spindex.setPower(0.1);
            spindexBusy = false;
        } else if (System.currentTimeMillis() - spindexStartTime > ANTI_JAM_TIME) {
            Spindex.setPower(-0.25);
            spindexStartTime = System.currentTimeMillis();
        }
    }

    boolean elapsed(long ms) { return System.currentTimeMillis() - stateTime >= ms; }
}
